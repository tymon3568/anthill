use async_trait::async_trait;
use chrono::Utc;
use std::sync::Arc;
use uuid::Uuid;

use inventory_service_core::domains::inventory::transfer::{
    Transfer, TransferItem, TransferPriority, TransferStatus, TransferType,
};
use inventory_service_core::dto::transfer::{
    ConfirmTransferRequest, ConfirmTransferResponse, CreateTransferRequest, CreateTransferResponse,
    ReceiveTransferRequest, ReceiveTransferResponse,
};
use inventory_service_core::repositories::stock::{InventoryLevelRepository, StockMoveRepository};
use inventory_service_core::repositories::transfer::{TransferItemRepository, TransferRepository};
use inventory_service_core::services::transfer::TransferService;
use shared_error::AppError;

/// PostgreSQL implementation of TransferService
pub struct PgTransferService {
    transfer_repo: Arc<dyn TransferRepository>,
    transfer_item_repo: Arc<dyn TransferItemRepository>,
    stock_move_repo: Arc<dyn StockMoveRepository>,
    inventory_repo: Arc<dyn InventoryLevelRepository>,
}

impl PgTransferService {
    /// Create a new service instance
    pub fn new(
        transfer_repo: Arc<dyn TransferRepository>,
        transfer_item_repo: Arc<dyn TransferItemRepository>,
        stock_move_repo: Arc<dyn StockMoveRepository>,
        inventory_repo: Arc<dyn InventoryLevelRepository>,
    ) -> Self {
        Self {
            transfer_repo,
            transfer_item_repo,
            stock_move_repo,
            inventory_repo,
        }
    }
}

#[async_trait]
impl TransferService for PgTransferService {
    async fn create_transfer(
        &self,
        tenant_id: Uuid,
        user_id: Uuid,
        request: CreateTransferRequest,
    ) -> Result<CreateTransferResponse, AppError> {
        // Validate warehouses are different
        if request.source_warehouse_id == request.destination_warehouse_id {
            return Err(AppError::ValidationError(
                "Source and destination warehouses must be different".to_string(),
            ));
        }

        // Parse dates
        let expected_ship_date = if let Some(date_str) = &request.expected_ship_date {
            Some(
                chrono::DateTime::parse_from_rfc3339(date_str)
                    .map_err(|_| {
                        AppError::ValidationError("Invalid expected_ship_date format".to_string())
                    })?
                    .with_timezone(&Utc),
            )
        } else {
            None
        };

        let expected_receive_date = if let Some(date_str) = &request.expected_receive_date {
            Some(
                chrono::DateTime::parse_from_rfc3339(date_str)
                    .map_err(|_| {
                        AppError::ValidationError(
                            "Invalid expected_receive_date format".to_string(),
                        )
                    })?
                    .with_timezone(&Utc),
            )
        } else {
            None
        };

        // Calculate totals
        let mut total_quantity = 0i64;
        let mut total_value = 0i64;

        let items: Vec<TransferItem> = request
            .items
            .into_iter()
            .enumerate()
            .map(|(i, item_req)| {
                let line_total = item_req.quantity * item_req.unit_cost.unwrap_or(0);
                total_quantity += item_req.quantity;
                total_value += line_total;

                TransferItem {
                    transfer_item_id: Uuid::now_v7(),
                    tenant_id,
                    transfer_id: Uuid::nil(), // Will be set after transfer creation
                    product_id: item_req.product_id,
                    quantity: item_req.quantity,
                    uom_id: item_req.uom_id,
                    unit_cost: item_req.unit_cost,
                    line_total,
                    line_number: item_req.line_number,
                    notes: item_req.notes,
                    created_at: Utc::now(),
                    updated_at: Utc::now(),
                    deleted_at: None,
                }
            })
            .collect();

        // Create transfer
        let transfer = Transfer {
            transfer_id: Uuid::now_v7(),
            tenant_id,
            transfer_number: String::new(), // Will be generated by DB
            reference_number: request.reference_number,
            source_warehouse_id: request.source_warehouse_id,
            destination_warehouse_id: request.destination_warehouse_id,
            status: TransferStatus::Draft,
            transfer_type: request.transfer_type,
            priority: request.priority,
            transfer_date: Utc::now(),
            expected_ship_date,
            actual_ship_date: None,
            expected_receive_date,
            actual_receive_date: None,
            shipping_method: request.shipping_method,
            carrier: None,
            tracking_number: None,
            shipping_cost: None,
            notes: request.notes,
            reason: request.reason,
            created_by: user_id,
            updated_by: Some(user_id),
            approved_by: None,
            approved_at: None,
            total_quantity,
            total_value,
            currency_code: "VND".to_string(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            deleted_at: None,
        };

        let created_transfer = self.transfer_repo.create(tenant_id, &transfer).await?;

        // Set transfer_id for items and create them
        let items_with_transfer_id: Vec<TransferItem> = items
            .into_iter()
            .map(|mut item| {
                item.transfer_id = created_transfer.transfer_id;
                item
            })
            .collect();

        let created_items = self
            .transfer_item_repo
            .create_batch(tenant_id, &items_with_transfer_id)
            .await?;

        Ok(CreateTransferResponse {
            transfer_id: created_transfer.transfer_id,
            transfer_number: created_transfer.transfer_number,
            status: created_transfer.status,
            items_count: created_items.len(),
        })
    }

    async fn confirm_transfer(
        &self,
        tenant_id: Uuid,
        transfer_id: Uuid,
        user_id: Uuid,
        _request: ConfirmTransferRequest,
    ) -> Result<ConfirmTransferResponse, AppError> {
        // Find transfer
        let transfer = self
            .transfer_repo
            .find_by_id(tenant_id, transfer_id)
            .await?
            .ok_or_else(|| AppError::NotFound("Transfer not found".to_string()))?;

        if transfer.status != TransferStatus::Draft {
            return Err(AppError::ValidationError(
                "Only draft transfers can be confirmed".to_string(),
            ));
        }

        // Get items
        let items = self
            .transfer_item_repo
            .find_by_transfer_id(tenant_id, transfer_id)
            .await?;

        // Create stock moves to transit location
        for item in &items {
            // Assuming transit location exists, create move from source to transit
            // This is simplified; in real implementation, need transit warehouse logic
            self.stock_move_repo
                .create_stock_move(
                    tenant_id,
                    transfer.source_warehouse_id,
                    transfer.destination_warehouse_id, // Simplified
                    item.product_id,
                    -(item.quantity), // Outgoing
                    Some(format!("Transfer {} confirmation", transfer.transfer_number)),
                    Some(transfer_id),
                )
                .await?;
        }

        // Update inventory levels
        for item in &items {
            self.inventory_repo
                .update_inventory_level(
                    tenant_id,
                    transfer.source_warehouse_id,
                    item.product_id,
                    -(item.quantity),
                )
                .await?;
        }

        // Confirm transfer
        self.transfer_repo
            .confirm_transfer(tenant_id, transfer_id, user_id, user_id)
            .await?;

        Ok(ConfirmTransferResponse {
            transfer_id,
            status: TransferStatus::Confirmed,
            confirmed_at: Utc::now().to_rfc3339(),
        })
    }

    async fn receive_transfer(
        &self,
        tenant_id: Uuid,
        transfer_id: Uuid,
        user_id: Uuid,
        _request: ReceiveTransferRequest,
    ) -> Result<ReceiveTransferResponse, AppError> {
        // Find transfer
        let transfer = self
            .transfer_repo
            .find_by_id(tenant_id, transfer_id)
            .await?
            .ok_or_else(|| AppError::NotFound("Transfer not found".to_string()))?;

        if transfer.status != TransferStatus::Shipped {
            return Err(AppError::ValidationError(
                "Only shipped transfers can be received".to_string(),
            ));
        }

        // Get items
        let items = self
            .transfer_item_repo
            .find_by_transfer_id(tenant_id, transfer_id)
            .await?;

        // Create stock moves to destination
        let mut stock_moves_created = 0;
        for item in &items {
            self.stock_move_repo
                .create_stock_move(
                    tenant_id,
                    transfer.source_warehouse_id, // From transit
                    transfer.destination_warehouse_id,
                    item.product_id,
                    item.quantity, // Incoming
                    Some(format!("Transfer {} receipt", transfer.transfer_number)),
                    Some(transfer_id),
                )
                .await?;
            stock_moves_created += 1;
        }

        // Update inventory levels
        for item in &items {
            self.inventory_repo
                .update_inventory_level(
                    tenant_id,
                    transfer.destination_warehouse_id,
                    item.product_id,
                    item.quantity,
                )
                .await?;
        }

        // Receive transfer
        self.transfer_repo
            .receive_transfer(tenant_id, transfer_id, user_id)
            .await?;

        // TODO: Publish inventory.transfer.completed event

        Ok(ReceiveTransferResponse {
            transfer_id,
            status: TransferStatus::Received,
            received_at: Utc::now().to_rfc3339(),
            stock_moves_created,
        })
    }
}
