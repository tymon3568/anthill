//! RMA service implementation
//!
//! This module contains the business logic implementation for RMA operations.

use async_trait::async_trait;
use chrono::Utc;
use std::sync::Arc;
use uuid::Uuid;

use inventory_service_core::dto::rma::{
    ApproveRmaRequest, ApproveRmaResponse, CreateRmaRequest, CreateRmaResponse, ReceiveRmaRequest,
    ReceiveRmaResponse,
};
use inventory_service_core::models::{
    CreateStockMoveRequest, RmaAction, RmaItem, RmaRequest, RmaStatus,
};
use inventory_service_core::repositories::{RmaItemRepository, RmaRepository, StockMoveRepository};
use inventory_service_core::services::rma::RmaService;
use shared_error::AppError;

/// PostgreSQL implementation of the RMA service
pub struct PgRmaService {
    rma_repo: Arc<dyn RmaRepository>,
    rma_item_repo: Arc<dyn RmaItemRepository>,
    stock_move_repo: Arc<dyn StockMoveRepository>,
}

impl PgRmaService {
    /// Create a new RMA service with the given repositories
    pub fn new(
        rma_repo: Arc<dyn RmaRepository>,
        rma_item_repo: Arc<dyn RmaItemRepository>,
        stock_move_repo: Arc<dyn StockMoveRepository>,
    ) -> Self {
        Self {
            rma_repo,
            rma_item_repo,
            stock_move_repo,
        }
    }
}

#[async_trait]
impl RmaService for PgRmaService {
    async fn create_rma(
        &self,
        tenant_id: Uuid,
        user_id: Uuid,
        request: CreateRmaRequest,
    ) -> Result<CreateRmaResponse, AppError> {
        // Validate request has items
        if request.items.is_empty() {
            return Err(AppError::ValidationError(
                "At least one item must be specified for RMA".to_string(),
            ));
        }

        // Calculate totals
        let mut total_items = 0i32;
        let mut total_value = 0i64;

        let items: Vec<RmaItem> = request
            .items
            .into_iter()
            .map(|item_req| {
                if item_req.quantity_returned <= 0 {
                    panic!("Quantity must be positive"); // Will be caught by validation
                }
                let line_total = item_req
                    .unit_cost
                    .map(|cost| cost * item_req.quantity_returned);
                total_items += item_req.quantity_returned as i32;
                if let Some(total) = line_total {
                    total_value += total;
                }

                RmaItem {
                    rma_item_id: Uuid::now_v7(),
                    tenant_id,
                    rma_id: Uuid::nil(), // Will be set after RMA creation
                    product_id: item_req.product_id,
                    variant_id: item_req.variant_id,
                    quantity_returned: item_req.quantity_returned,
                    condition: item_req.condition,
                    action: item_req.action,
                    unit_cost: item_req.unit_cost,
                    line_total,
                    notes: item_req.notes,
                    created_by: Some(user_id),
                    updated_by: Some(user_id),
                    created_at: Utc::now(),
                    updated_at: Utc::now(),
                    deleted_at: None,
                }
            })
            .collect();

        // Create RMA request
        let rma = RmaRequest {
            rma_id: Uuid::now_v7(),
            rma_number: "".to_string(), // Will be generated by DB
            tenant_id,
            customer_id: request.customer_id,
            original_delivery_id: request.original_delivery_id,
            status: RmaStatus::Draft,
            return_reason: request.return_reason,
            notes: request.notes,
            total_items,
            total_value,
            currency_code: "VND".to_string(),
            created_by: Some(user_id),
            updated_by: Some(user_id),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            deleted_at: None,
        };

        self.rma_repo.create(&rma).await?;

        // Set rma_id for items and create them
        let items_with_rma_id: Vec<RmaItem> = items
            .into_iter()
            .map(|mut item| {
                item.rma_id = rma.rma_id;
                item
            })
            .collect();

        for item in &items_with_rma_id {
            self.rma_item_repo.create(item).await?;
        }

        // Fetch the created RMA to get the generated number
        let final_rma = self
            .rma_repo
            .find_by_id(tenant_id, rma.rma_id)
            .await?
            .ok_or_else(|| AppError::InternalError("Failed to retrieve created RMA".to_string()))?;

        Ok(CreateRmaResponse {
            rma_id: final_rma.rma_id,
            rma_number: final_rma.rma_number,
            status: final_rma.status,
            created_at: final_rma.created_at,
        })
    }

    async fn approve_rma(
        &self,
        tenant_id: Uuid,
        rma_id: Uuid,
        user_id: Uuid,
        request: ApproveRmaRequest,
    ) -> Result<ApproveRmaResponse, AppError> {
        // Find the RMA
        let rma = self
            .rma_repo
            .find_by_id(tenant_id, rma_id)
            .await?
            .ok_or_else(|| AppError::NotFound(format!("RMA {} not found", rma_id)))?;

        // Check if the RMA is in a valid state for approval
        if rma.status != RmaStatus::Draft {
            return Err(AppError::ValidationError(format!(
                "Cannot approve RMA with status {}. Only Draft RMAs can be approved.",
                rma.status
            )));
        }

        let new_status = if request.approved {
            RmaStatus::Approved
        } else {
            RmaStatus::Rejected
        };

        let approved_at = Utc::now();

        // Update status
        self.rma_repo
            .update_status(tenant_id, rma_id, new_status.clone(), Some(user_id))
            .await?;

        Ok(ApproveRmaResponse {
            rma_id,
            status: new_status,
            approved_at,
        })
    }

    async fn receive_rma(
        &self,
        tenant_id: Uuid,
        rma_id: Uuid,
        user_id: Uuid,
        request: ReceiveRmaRequest,
    ) -> Result<ReceiveRmaResponse, AppError> {
        // Find the RMA
        let rma = self
            .rma_repo
            .find_by_id(tenant_id, rma_id)
            .await?
            .ok_or_else(|| AppError::NotFound(format!("RMA {} not found", rma_id)))?;

        // Check if the RMA is in a valid state for receiving
        if rma.status != RmaStatus::Approved {
            return Err(AppError::ValidationError(format!(
                "Cannot receive RMA with status {}. Only Approved RMAs can be received.",
                rma.status
            )));
        }

        // Get RMA items
        let rma_items = self.rma_item_repo.find_by_rma_id(tenant_id, rma_id).await?;

        let mut stock_moves_created = 0;
        let received_at = Utc::now();

        // Process received items
        for received_item in &request.received_items {
            // Find the RMA item
            let rma_item = rma_items
                .iter()
                .find(|item| item.rma_item_id == received_item.rma_item_id)
                .ok_or_else(|| {
                    AppError::NotFound(format!(
                        "RMA item {} not found in RMA {}",
                        received_item.rma_item_id, rma_id
                    ))
                })?;

            // For items being restocked, create stock move from Customer virtual location back to warehouse
            if rma_item.action == RmaAction::Restock {
                // Assume we have a "Customer" virtual location and a main warehouse
                // In a real implementation, you would need to determine the appropriate destination location
                // For now, we will use a placeholder destination_location_id
                let destination_location_id = None; // TODO: Determine actual warehouse location

                let stock_move = CreateStockMoveRequest {
                    product_id: rma_item.product_id,
                    source_location_id: None, // Customer virtual location
                    destination_location_id,
                    move_type: "rma_return".to_string(),
                    quantity: received_item.received_quantity,
                    unit_cost: rma_item.unit_cost,
                    reference_type: "rma".to_string(),
                    reference_id: rma_id,
                    idempotency_key: format!("rma-{}-item-{}", rma_id, rma_item.rma_item_id),
                    move_reason: Some(format!("RMA {} return", rma.rma_number)),
                    batch_info: None,
                    metadata: Some(serde_json::json!({
                        "rma_item_id": rma_item.rma_item_id,
                        "condition": received_item.condition,
                        "action": rma_item.action
                    })),
                };

                self.stock_move_repo.create(&stock_move, tenant_id).await?;
                stock_moves_created += 1;
            }
        }

        // Update RMA status to Received
        self.rma_repo
            .update_status(tenant_id, rma_id, RmaStatus::Received, Some(user_id))
            .await?;

        Ok(ReceiveRmaResponse {
            rma_id,
            status: RmaStatus::Received,
            received_at,
            stock_moves_created,
        })
    }
}
